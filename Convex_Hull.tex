\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Parallel Convex Hull Algorithms\\}

\author{\IEEEauthorblockN{Matthew Molter, mm58286}
\IEEEauthorblockA{\textit{Cockrell School of Engineering} \\
\textit{University of Texas at Austin}\\
Austin, TX \\
m.molter@utexas.edu}
\and
\IEEEauthorblockN{Joaquin Ambia Garrido, ja43578}
\IEEEauthorblockA{\textit{Cockrell School of Engineering} \\
\textit{University of Texas at Austin}\\
Austin, TX \\
ambia@utexas.edu}
}

\maketitle

\begin{abstract}
This serves as a summary of the fall 2020 semester project for Multicore Computing by the two authors. It serves as an exploration of current techniques in parallel convex hull algorithms, as well as a comparison to serial 
\end{abstract}

\section{Introduction}
The convex hull algorithm has been fairly extensively examined in the literature dating back at least to the 1970s. The premise behind the problem is that given an arbitrary set of points, the convex hull is the smallest convex set that contains it. This means that given any two points within the hull, the entirety of the line that connects them is contained within the hull. It is an interesting problem in geometry with applications in numerous spaces, such as image processing, scientific computing (in particular quantum mechanics), and economic analysis.

It has been noted that despite the large number of serial algorithms for the computation of the convex hull, there are a surprisingly small number of parallel algorithms. Most parallel algorithms can be divided into one of two categories: 
\begin{enumerate}
    \item divide and conquer, where numerous smaller hulls are found and then combined into a single hull, as examined in [1] and [2]
    \item parallelization of iterative sequential algorithms, as examined in [3] and [4]
\end{enumerate} 

\section{Summary of Convex Hull}


\section{Serial Algorithm}
In the serial algorithm, a stack is used to detect concavity and remove points from the hull. There is only one assumption made by this algorithm: that the points have already been sorted in increasing order by x-value. 

The algorithm begins by finding the left most and right most points, a trivial exercise since the points have already been sorted by their horizontal position. It then effectively draws a line between the two points, and points above that line are put into the group for what will be referred to as the $upper hull$ and points below that line are moved into the $lower hull$. Once the upper/lower sets have been created, we can begin the algorithm to calculate the hull. The method is effectively the same for the upper and lower sets, so we will discuss only the upper in detail for brevity.

As a quick aside, the stack used is for the most part one that the reader will be familiar with. The sole exception is that in addition to the familiar $push/pop/peek$ methods normally performed by a stack, this stack has an additional $second$ method, which will return not the top value, but the value underneath. This is critical for allowing us to determine concavity.

To begin with, the first two elements are pushed onto the stack. Once there are two elements, we can proceed with comparison. The next element in line to be pushed to the stack is taken with the $second$ element in order to form a virtual line. We then examine the $top$ element in relation to this line, in our algorithm, via projection. If the $top$ element in the stack is above this line, then the surface formed by the three elements in comparison is convex. This means there is no action to be performed, so the next element is pushed onto the stack and the comparison repeated.

If the $top$ element happens to be below the line formed by the $second$ element and the next element, then this is evidence of a concave surface. In order to remedy this, the $top$ element is popped from the stack before pushing the next element on to the stack. Again, the comparison is then repeated.

This algorithm ends when we reach the furthest most right point of the set. Once that occurs, the hull is considered found. As stated above, the lower hull algorithm proceeds in a nearly identical manner, just with opposite orientation. In the serial algorithm, the lower hull is found after the upper hull has finished. Each hull is found in $O(n)$ time. This should be obvious, as each element can be at most pushed once, and at most popped once. Once both hulls have been found, the connecting point is the left/right extremities, so combination can occur in $O(n)$ time as well if copying elements.

As can be seen above, given a sorted set of elements, a convex hull in $O(n)$ time is trivial. However, sorting is a $O(nlog(n)$ problem at best, which dominates the run time on large datasets. As a result, comparisons will be made to the parallel algorithm only in the portion in which the hull is actually calculated. Comparison of sorting algorithms is beyond the scope of this paper.

\section{Parallelization Approach 1 - Divide and Conquer}
The divide in conquer section is a relatively straightforward approach to parallelization, and likely the first idea that one would have if they were assigned the task of making a parallel algorithm for convex hull computation. Given a set $S$ of points, and $n$ processes, $S$ is divided into $n$ equal sets. The upper hull of each set is found, and then the hulls are connected to each other in order to find a complete convex hull of the entire set.

This approach offers the advantage that it is relatively simple to implement. Nearly any serial algorithm for finding a convex hull can be used to find each hull, and can be easily parallelized by simply breaking up the workload appropriately. The worst case time bound is $\Omega(n log n)$ for any convex hull algorithm. The combination portion of the algorithm is most commonly done in serial, as it is a relatively quick computation.

To begin with, the set of points is divided among its extreme edges into upper and lower hulls, allowing for calculation of each separately to be combined. This simplifies the serial algorithm, as well as provides an excellent opportunity for parallelization. The upper/lower hulls are treated in exactly the same manner, so the description which follows covers only the upper hull for expediency.

Once the set of points to be contained has been split, it is further divided into $n$ disjoint sets, where $n$ is your number of processors. This allows each set to be handled individually with no interference. Since the set has already been ordered, this means that each split set contains only neighboring points with no overlap between sets. What this serves to do is allow us to calculate each hull separately, knowing that there will be limited modification during the combination step.

\section{Parallelization Approach 2}

\section{References}
\begin{thebibliography}{00}
\bibitem{b1} M. Nakagawa, D. Man, Y. Ito, and K. Nakano, “A Simple Parallel Convex Hulls Algorithm for Sorted Points and the Performance Evaluation on the Multicore Processors,” Hiroshima University. [Online]. [Accessed: 11-Nov-2020].
\bibitem{b2} J. Ramesh and S. Suresha, “Convex Hull - Parallel and Distributed Algorithms,” Stanford.edu,
2016. [Online]. [Accessed: 11-Nov-2020].
\bibitem{b3} R. Miller and Q. F. Stout, “Efficient parallel convex hull algorithms,” IEEE Transactions on Computers, vol. 37, no. 12, pp. 1605–1618, 1988.
\bibitem{b4} J. Liu, “Parallel Algorithms for Constructing Convex Hulls,” dissertation, LSU Historical Dissertations and Theses, Baton Rouge, LA, 1995.
\end{thebibliography}


\end{document}
